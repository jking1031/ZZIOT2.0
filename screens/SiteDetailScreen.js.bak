import React, { useEffect, useState, useRef, useCallback } from 'react';
import { StyleSheet, View, Text, ScrollView, RefreshControl, Modal, TextInput, TouchableOpacity, AppState, Platform } from 'react-native';
import { useTheme } from '../context/ThemeContext';
import axios from 'axios';

// 添加全局引用，解决组件重复挂载问题
const globalWSRef = { current: null };
const globalHeartbeatRef = { current: null };
const globalReconnectTimeoutRef = { current: null };
const globalConnected = { current: false };

function SiteDetailScreen({ route, navigation }) {
  const { colors, isDarkMode } = useTheme();
  const { siteId, siteName } = route.params;
  const [refreshing, setRefreshing] = useState(false);
  const [inData, setInData] = useState([]);
  const [outData, setOutData] = useState([]);
  const [lastUpdateTime, setLastUpdateTime] = useState(null);
  const [devices, setDevices] = useState([]);
  const [deviceFrequency, setDeviceFrequency] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedDevice, setSelectedDevice] = useState(null);
  const [newFrequency, setNewFrequency] = useState('');
  const [isValve, setIsValve] = useState([]);
  const [updateTimer, setUpdateTimer] = useState(null);
  const [appState, setAppState] = useState(AppState.currentState);
  
  // WebSocket相关状态
  const [wsConnected, setWsConnected] = useState(globalConnected.current);
  const [pendingCommands, setPendingCommands] = useState({});
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  
  // 引用 - 保留本地引用但优先使用全局引用
  const currentAppState = useRef(AppState.currentState);
  const timerRef = useRef(null);
  const controllerRef = useRef(null);
  const wsRef = useRef(globalWSRef.current); // 使用全局WS引用
  const heartbeatIntervalRef = useRef(globalHeartbeatRef.current);
  const reconnectTimeoutRef = useRef(globalReconnectTimeoutRef.current);

  const fetchSiteDetail = useCallback(async () => {
    if (controllerRef.current) {
      controllerRef.current.abort();
    }
    
    const controller = new AbortController();
    controllerRef.current = controller;

    try {
      console.log('开始获取站点详情数据...');
      const response = await axios.get(`https://nodered.jzz77.cn:9003/api/sites/site/${siteId}`, {
        signal: controller.signal,
        timeout: 10000
      });

      if (response.data) {
        const data = response.data;
        if (data.indata) setInData(data.indata);
        if (data.outdata) setOutData(data.outdata);
        if (data.devices) setDevices(data.devices);
        if (data.deviceFrequency) setDeviceFrequency(data.deviceFrequency);
        if (data.isValve) setIsValve(data.isValve);
        setLastUpdateTime(new Date());
      }
    } catch (error) {
      if (axios.isCancel(error)) {
        console.log('请求被取消');
      } else {
        console.error('获取站点数据失败:', error);
      }
    }
  }, [siteId]);

  const startDataFetching = useCallback(() => {
    // 避免重复调用
    if (!timerRef.current) {
      fetchSiteDetail();
      timerRef.current = setInterval(() => fetchSiteDetail(), 30000);
      setUpdateTimer(timerRef.current);
    }
  }, [fetchSiteDetail]);

  const stopDataFetching = useCallback(() => {
    // 清除定时器
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
      setUpdateTimer(null);
    }
    
    // 取消正在进行的请求
    if (controllerRef.current) {
      controllerRef.current.abort();
      controllerRef.current = null;
    }
  }, []);

  // 修改setupWebSocket以使用全局引用
  const setupWebSocket = useCallback(() => {
    // 严格检查，不允许在未进入页面的状态下建立连接
    if (!navigation.isFocused()) {
      console.log('页面未获得焦点，取消WebSocket连接尝试');
      return;
    }
    
    console.log('尝试建立WebSocket连接...');
    
    // 防止重复连接 - 更全面的状态检查
    if (globalWSRef.current) {
      // 使用全局引用检查连接状态
      if (globalWSRef.current.readyState === WebSocket.CONNECTING) {
        console.log('WebSocket连接正在建立中，忽略重复请求');
        wsRef.current = globalWSRef.current; // 确保本地引用同步
        return;
      }
      
      if (globalWSRef.current.readyState === WebSocket.OPEN) {
        console.log('WebSocket已连接，无需重新连接');
        wsRef.current = globalWSRef.current; // 确保本地引用同步
        
        // 如果全局连接已存在，但本地状态未更新，则更新本地状态
        if (!wsConnected) {
          console.log('更新本地连接状态');
          setWsConnected(true);
          globalConnected.current = true;
        }
        return;
      }
      
      // 重要: 移除所有旧事件监听器
      const oldSocket = globalWSRef.current;
      oldSocket.onclose = null; // 阻止旧连接触发重连
      oldSocket.onerror = null;
      oldSocket.onopen = null;
      oldSocket.onmessage = null;
      
      try {
        if (oldSocket.readyState === WebSocket.CONNECTING || 
            oldSocket.readyState === WebSocket.OPEN) {
          console.log('关闭现有WebSocket连接');
          oldSocket.close();
        }
      } catch (e) {
        console.log('关闭旧连接时出错:', e);
      }
      
      globalWSRef.current = null;
      wsRef.current = null;
    }
    
    // 清除任何现有重连计时器
    if (globalReconnectTimeoutRef.current) {
      clearTimeout(globalReconnectTimeoutRef.current);
      globalReconnectTimeoutRef.current = null;
      reconnectTimeoutRef.current = null;
    }
    
    // 如果重连次数过多，延长等待时间并限制最大尝试次数
    if (reconnectAttempts > 10) {
      console.log(`重连尝试次数过多(${reconnectAttempts})，暂停重连过程`);
      setWsConnected(false);
      return;
    }
    
    // 创建新连接
    try {
      console.log('正在建立WebSocket连接...', new Date().toISOString());
      // 添加时间戳和随机数，避免缓存问题
      const socket = new WebSocket(`wss://nodered.jzz77.cn:9003/ws/device?t=${Date.now()}&client=mobile`);
      
      socket.onopen = () => {
        console.log('WebSocket连接已建立', new Date().toISOString());
        setWsConnected(true);
        globalConnected.current = true;
        setReconnectAttempts(0); // 重置重连计数
        
        // 连接建立后立即发送一个初始化消息，帮助服务器识别连接
        try {
          socket.send(JSON.stringify({
            type: 'init',
            siteId,
            clientInfo: {
              platform: Platform.OS,
              version: Platform.Version,
              timestamp: Date.now()
            }
          }));
          console.log('已发送初始化消息');
        } catch (e) {
          console.error('发送初始化消息失败:', e);
        }
        
        // 连接成功后延迟1秒再请求设备状态
        setTimeout(() => {
          if (socket.readyState === WebSocket.OPEN) {
            try {
              socket.send(JSON.stringify({
                type: 'get_device_status',
                siteId
              }));
              console.log('已发送设备状态请求');
            } catch (e) {
              console.error('发送状态请求失败:', e);
            }
          }
        }, 1000);
      };
      
      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('收到WebSocket消息:', data);
          
          if (data.type === 'pong') {
            // 处理心跳响应
            return;
          }
          
          if (data.type === 'device_status') {
            // 更新设备状态
            handleDeviceStatusUpdate(data);
          }
          
          if (data.type === 'command_feedback') {
            // 处理命令反馈
            handleCommandFeedback(data);
          }
          
          // 处理状态请求确认
          if (data.type === 'status_request_received') {
            console.log('服务器已接收状态请求:', data.message);
          }
        } catch (error) {
          console.error('解析WebSocket消息失败:', error);
        }
      };
      
      socket.onclose = (event) => {
        console.log(`WebSocket连接已关闭: ${event.code} ${event.reason}`);
        setWsConnected(false);
        
        // 清理心跳定时器
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current);
          heartbeatIntervalRef.current = null;
        }
        
        // 仅在应用前台且页面焦点在当前页面且未达到最大重试次数时重连
        if (AppState.currentState === 'active' && navigation.isFocused()) {
          // 正常关闭(1000)或未授权(1003)不需要重试
          if (event.code === 1000 || event.code === 1003) {
            console.log('连接正常关闭或未授权，不进行重连');
            return;
          }
          
          // 如果服务器回复502等错误，使用更长的重连延迟
          let baseDelay = 1000;
          if (event.reason && event.reason.includes('502')) {
            baseDelay = 5000;
            console.log('检测到服务器502错误，使用更长的重连延迟');
          }
          
          const maxReconnectDelay = 60000; // 最大60秒重连间隔
          const delay = Math.min(baseDelay * Math.pow(1.5, reconnectAttempts), maxReconnectDelay);
          console.log(`将在 ${delay}ms 后重连 (尝试 ${reconnectAttempts + 1})`);
          
          reconnectTimeoutRef.current = setTimeout(() => {
            // 再次检查页面是否仍然可见
            if (navigation.isFocused()) {
              setReconnectAttempts(prev => prev + 1);
              setupWebSocket();
            } else {
              console.log('页面已不可见，取消重连');
            }
          }, delay);
        }
      };
      
      socket.onerror = (error) => {
        console.error('WebSocket连接错误:', error);
      };
      
      // 使用全局引用保存socket
      globalWSRef.current = socket;
      wsRef.current = socket;
      
      // 设置心跳
      setupHeartbeat();
      
    } catch (error) {
      console.error('创建WebSocket连接失败:', error);
      setWsConnected(false);
      
      // 连接失败也增加重试计数，但仅在页面可见时
      if (navigation.isFocused()) {
        const delay = Math.min(1000 * Math.pow(1.5, reconnectAttempts), 30000);
        reconnectTimeoutRef.current = setTimeout(() => {
          setReconnectAttempts(prev => prev + 1);
          setupWebSocket();
        }, delay);
      }
    }
  }, [siteId, reconnectAttempts, navigation, handleDeviceStatusUpdate, handleCommandFeedback, setupHeartbeat]);
  
  // 修改心跳机制使用全局引用
  const setupHeartbeat = useCallback(() => {
    if (globalHeartbeatRef.current) {
      clearInterval(globalHeartbeatRef.current);
    }
    
    globalHeartbeatRef.current = setInterval(() => {
      if (globalWSRef.current && globalWSRef.current.readyState === WebSocket.OPEN) {
        try {
          console.log('发送心跳...');
          globalWSRef.current.send(JSON.stringify({ 
            type: 'ping', 
            timestamp: Date.now(),
            siteId,
            clientId: `mobile_${Platform.OS}_${Math.random().toString(36).substring(7)}`
          }));
        } catch (e) {
          console.error('发送心跳失败:', e);
          // 心跳失败，尝试重新连接
          if (globalWSRef.current) {
            globalWSRef.current.close();
          }
        }
      }
    }, 15000); // 降低到15秒发送一次心跳
    
    heartbeatIntervalRef.current = globalHeartbeatRef.current;
  }, [siteId]);
  
  // 处理设备状态更新
  const handleDeviceStatusUpdate = useCallback((data) => {
    // 处理设备运行状态更新
    if (data.devices && Array.isArray(data.devices)) {
      setDevices(prevDevices => {
        return prevDevices.map(device => {
          const updatedDevice = data.devices.find(d => d.name === device.name);
          if (updatedDevice) {
            return { ...device, ...updatedDevice };
          }
          return device;
        });
      });
    }
    
    // 处理阀门状态更新
    if (data.valves && Array.isArray(data.valves)) {
      setIsValve(prevValves => {
        return prevValves.map(valve => {
          const updatedValve = data.valves.find(v => v.name === valve.name);
          if (updatedValve) {
            return { ...valve, ...updatedValve };
          }
          return valve;
        });
      });
    }
    
    // 处理频率设备更新
    if (data.frequencies && Array.isArray(data.frequencies)) {
      setDeviceFrequency(prevFreq => {
        return prevFreq.map(freq => {
          const updatedFreq = data.frequencies.find(f => f.name === freq.name);
          if (updatedFreq) {
            return { ...freq, ...updatedFreq };
          }
          return freq;
        });
      });
    }
    
    // 更新最后一次更新时间
    setLastUpdateTime(new Date());
  }, []);
  
  // 处理命令反馈
  const handleCommandFeedback = useCallback((data) => {
    const deviceId = data.deviceId || data.deviceName || data.valveName;
    
    if (deviceId) {
      // 更新命令状态
      setPendingCommands(prev => ({
        ...prev,
        [deviceId]: {
          status: data.success ? 'success' : 'error',
          message: data.message,
          timestamp: Date.now()
        }
      }));
      
      // 如果是成功的反馈，3秒后自动清除状态显示
      if (data.success) {
        setTimeout(() => {
          setPendingCommands(prev => {
            const newState = { ...prev };
            delete newState[deviceId];
            return newState;
          });
        }, 3000);
      }
    }
  }, []);
  
  // 修改WebSocket发送命令函数使用全局引用
  const sendCommandWs = useCallback((command) => {
    // 优先使用全局引用
    const activeWS = globalWSRef.current || wsRef.current;
    
    if (!activeWS || activeWS.readyState !== WebSocket.OPEN) {
      console.error('WebSocket未连接，无法发送命令');
      return Promise.reject(new Error('WebSocket未连接'));
    }
    
    // 显示处理中状态
    setPendingCommands(prev => ({
      ...prev,
      [command.deviceName || command.valveName]: {
        status: 'pending',
        timestamp: Date.now()
      }
    }));
    
    // 发送命令
    activeWS.send(JSON.stringify({
      ...command,
      type: 'command',
      siteId,
      timestamp: Date.now()
    }));
    
    // 设置5秒超时
    setTimeout(() => {
      setPendingCommands(prev => {
        // 如果5秒后仍是pending状态，显示超时
        if (prev[command.deviceName || command.valveName]?.status === 'pending') {
          return {
            ...prev,
            [command.deviceName || command.valveName]: { 
              status: 'timeout', 
              message: '响应超时，请检查设备状态',
              timestamp: Date.now() 
            }
          };
        }
        return prev;
      });
    }, 5000);
    
    return Promise.resolve();
  }, [siteId]);

  // 统一处理组件挂载、页面焦点变化和应用状态变化
  useEffect(() => {
    // 设置页面标题
    navigation.setOptions({
      title: siteName || '站点详情'
    });

    // 初始获取数据并开始定时更新
    startDataFetching();
    
    console.log('SiteDetailScreen组件已挂载', new Date().toISOString());
    
    // 检查是否已有全局连接
    if (globalWSRef.current && globalWSRef.current.readyState === WebSocket.OPEN) {
      console.log('发现已有全局连接，复用现有连接');
      wsRef.current = globalWSRef.current;
      setWsConnected(true);
    }
    
    // 仅当页面获得焦点时处理WebSocket连接
    let hadFocus = false; // 记录是否曾经获得过焦点
    
    // 处理页面焦点变化
    const focusUnsubscribe = navigation.addListener('focus', () => {
      console.log('页面获得焦点，确保数据刷新', new Date().toISOString());
      startDataFetching();
      
      // 确保只有在实际用户交互导致的焦点变化才连接WebSocket
      // 延迟连接以避免启动时的自动连接
      setTimeout(() => {
        if (navigation.isFocused()) {
          console.log('页面可见，检查WebSocket连接', new Date().toISOString());
          hadFocus = true;
          
          // 只有在WebSocket未连接时才尝试连接
          if (!globalConnected.current && !globalWSRef.current) {
            console.log('全局连接不存在，建立新连接');
            setupWebSocket();
          } else if (globalWSRef.current && globalWSRef.current.readyState === WebSocket.OPEN) {
            console.log('全局连接存在，设置连接状态');
            wsRef.current = globalWSRef.current;
            setWsConnected(true);
          }
        }
      }, 500);
    });
    
    const blurUnsubscribe = navigation.addListener('blur', () => {
      console.log('页面失去焦点，停止数据刷新');
      stopDataFetching();
      // 页面失去焦点时不关闭WebSocket
    });

    // 处理应用状态变化
    const appStateSubscription = AppState.addEventListener('change', nextAppState => {
      if (currentAppState.current.match(/inactive|background/) && nextAppState === 'active') {
        // 应用从后台恢复
        console.log('应用从后台恢复，刷新数据');
        
        if (navigation.isFocused()) {
          startDataFetching();
          
          // 只有在WebSocket未连接且页面曾经获得过焦点时才尝试连接
          if (!globalConnected.current && !globalWSRef.current && hadFocus) {
            console.log('应用从后台恢复，重新连接WebSocket');
            setupWebSocket();
          }
        }
      } else if (nextAppState.match(/inactive|background/)) {
        // 应用进入后台
        console.log('应用进入后台，暂停数据刷新');
        stopDataFetching();
        // 不关闭WebSocket连接，允许后台接收推送
      }
      currentAppState.current = nextAppState;
    });

    // 重要修改：清理函数不再立即关闭WebSocket
    return () => {
      console.log('组件卸载，但保留全局WebSocket连接', new Date().toISOString());
      stopDataFetching();
      focusUnsubscribe();
      blurUnsubscribe();
      appStateSubscription.remove();
      
      // 关键变化：不立即关闭WebSocket，而是保留给其他实例使用
      // 只清除本地引用，但保留全局引用
      wsRef.current = null;
      
      // 仅清除本地计时器引用
      heartbeatIntervalRef.current = null;
      reconnectTimeoutRef.current = null;
    };
  }, [navigation, siteName, startDataFetching, stopDataFetching, setupWebSocket, wsConnected]);

  // 添加一个组件卸载前的清理函数，只在应用真正退出时执行
  useEffect(() => {
    // 此效果仅处理应用退出时的清理
    return () => {
      // 应用退出时才清理全局资源
      const isLastInstance = navigation.getState().routes.findIndex(
        route => route.name === 'SiteDetailScreen'
      ) === -1;
      
      if (isLastInstance && globalWSRef.current) {
        console.log('应用退出，清理全局WebSocket资源');
        
        if (globalWSRef.current.readyState === WebSocket.OPEN) {
          try {
            // 发送关闭消息
            globalWSRef.current.send(JSON.stringify({
              type: 'client_close',
              siteId,
              reason: 'app_exit'
            }));
          } catch (e) {
            console.error('发送关闭消息失败:', e);
          }
        }
        
        // 移除所有事件监听器
        globalWSRef.current.onclose = null;
        globalWSRef.current.onerror = null;
        globalWSRef.current.onopen = null;
        globalWSRef.current.onmessage = null;
        
        try {
          globalWSRef.current.close(1000, "Normal closure");
        } catch (e) {
          console.error('关闭WebSocket连接错误:', e);
        }
        
        globalWSRef.current = null;
        globalConnected.current = false;
      }
      
      if (globalHeartbeatRef.current) {
        clearInterval(globalHeartbeatRef.current);
        globalHeartbeatRef.current = null;
      }
      
      if (globalReconnectTimeoutRef.current) {
        clearTimeout(globalReconnectTimeoutRef.current);
        globalReconnectTimeoutRef.current = null;
      }
    };
  }, [navigation, siteId]);

  // 保留原有HTTP控制命令逻辑作为备份
  const sendCommand = async (command) => {
    try {
      const response = await axios.post(`https://nodered.jzz77.cn:9003/api/site/${siteId}/command`, command, {
        timeout: 10000,
        validateStatus: function (status) {
          return status >= 200 && status < 300;
        }
      });
      
      // 发送命令后立即获取最新数据
      await fetchSiteDetail();
      return response.data;
    } catch (error) {
      console.error('发送控制命令失败:', error);
      throw error;
    }
  };

  // 修改设备控制函数使用WebSocket
  const handleDeviceControl = async (deviceName, action) => {
    try {
      // 使用WebSocket发送命令
      await sendCommandWs({
        type: 'device_control',
        deviceName,
        action
      });
    } catch (error) {
      console.error('设备控制失败:', error);
      // 如果WebSocket失败，尝试回退到HTTP
      try {
        await sendCommand({
          type: 'device_control',
          deviceName,
          action
        });
      } catch (httpError) {
        console.error('HTTP设备控制也失败:', httpError);
      }
    }
  };

  // 修改阀门控制函数使用WebSocket
  const handleValveControl = async (valveName, action, openKey, closeKey) => {
    try {
      // 使用WebSocket发送命令
      await sendCommandWs({
        type: 'valve_control',
        valveName,
        action,
        openKey,
        closeKey
      });
    } catch (error) {
      console.error('阀门控制失败:', error);
      // 如果WebSocket失败，尝试回退到HTTP
      try {
        await sendCommand({
          type: 'valve_control',
          valveName,
          action,
          openKey,
          closeKey
        });
      } catch (httpError) {
        console.error('HTTP阀门控制也失败:', httpError);
      }
    }
  };

  // 修改频率设置函数使用WebSocket
  const handleSetFrequency = async (deviceName, frequency) => {
    try {
      // 使用WebSocket发送命令
      await sendCommandWs({
        type: 'set_frequency',
        deviceName,
        frequency: parseFloat(frequency)
      });
    } catch (error) {
      console.error('设置频率失败:', error);
      // 如果WebSocket失败，尝试回退到HTTP
      try {
        await sendCommand({
          type: 'set_frequency',
          deviceName,
          frequency: parseFloat(frequency)
        });
      } catch (httpError) {
        console.error('HTTP设置频率也失败:', httpError);
      }
    }
  };

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    await fetchSiteDetail();
    setRefreshing(false);
  }, []);

  // 操作状态显示组件
  const CommandStatusDisplay = ({ deviceId }) => {
    const command = pendingCommands[deviceId];
    
    if (!command) return null;
    
    let statusColor, statusText, icon;
    
    switch (command.status) {
      case 'pending':
        statusColor = '#FFA000';
        statusText = '处理中...';
        icon = '⏳';
        break;
      case 'success':
        statusColor = '#4CAF50';
        statusText = command.message || '操作成功';
        icon = '✓';
        break;
      case 'error':
        statusColor = '#FF5252';
        statusText = command.message || '操作失败';
        icon = '⚠️';
        break;
      case 'timeout':
        statusColor = '#FF9800';
        statusText = '响应超时';
        icon = '⏱️';
        break;
      default:
        return null;
    }
    
    return (
      <View style={[styles.statusBadge, { borderColor: statusColor }]}>
        <Text style={{ color: statusColor }}>{icon} {statusText}</Text>
      </View>
    );
  };

  // 连接状态组件
  const ConnectionStatus = () => (
    <View style={styles.wsStatusContainer}>
      <View style={[
        styles.statusIndicator, 
        { backgroundColor: wsConnected ? '#4CAF50' : '#FF5252' }
      ]} />
      <Text style={[styles.statusText, { color: colors.text }]}>
        {wsConnected 
          ? '设备控制协议已连接' 
          : '设备控制协议未连接'}
      </Text>
    </View>
  );

  const renderDataCard = (item, index) => (
    <View
      key={`${item.name}-${index}`}
      style={[
        styles.card,
        { backgroundColor: colors.card },
        item.alarm === 1 && styles.alarmCard
      ]}
    >
      <Text style={[styles.cardTitle, { color: colors.text }]}>{item.name}</Text>
      <View style={styles.dataContainer}>
        <Text style={[styles.dataValue, { color: item.alarm === 1 ? '#FF5252' : colors.text }]}>
          {item.data.toFixed(2)}
        </Text>
        <Text style={[styles.dataUnit, { color: colors.text }]}>{item.dw}</Text>
      </View>
    </View>
  );

  return (
    <View style={{ flex: 1 }}>
      <ScrollView
        style={[styles.container, { backgroundColor: colors.background }]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#2196F3']}
            tintColor={colors.text}
          />
        }
      >
      <View style={styles.connectionStatusContainer}>
        <View style={styles.connectionRow}>
          <View style={[styles.connectionStatus, { backgroundColor: updateTimer ? '#4CAF50' : '#FF5252' }]} />
          <Text style={[styles.connectionText, { color: colors.text }]}>
            {updateTimer ? '自动更新已开启' : '自动更新已关闭'}
          </Text>
        </View>
        
        <View style={styles.connectionRow}>
          <ConnectionStatus />
          {lastUpdateTime && (
            <Text style={[styles.lastUpdateText, { color: colors.text }]}>
              最后更新：{lastUpdateTime.toLocaleString('zh-CN', { hour12: false })}
            </Text>
          )}
        </View>
      </View>

      {inData.length > 0 && (
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>进水数据</Text>
          <View style={styles.cardGrid}>
            {inData.map(renderDataCard)}
          </View>
        </View>
      )}

      {outData.length > 0 && (
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>出水数据</Text>
          <View style={styles.cardGrid}>
            {outData.map(renderDataCard)}
          </View>
        </View>
      )}

      {deviceFrequency.length > 0 && (
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>设备频率</Text>
          <View style={styles.cardGrid}>
            {deviceFrequency.map((item) => (
              <TouchableOpacity
                key={item.name}
                style={[styles.card, { backgroundColor: colors.card }]}
                onPress={() => {
                  setSelectedDevice(item);
                  setNewFrequency(item.sethz?.toString() || '');
                  setModalVisible(true);
                }}
                disabled={pendingCommands[item.name]?.status === 'pending'}
              >
                <Text style={[styles.cardTitle, { color: colors.text }]}>{item.name}</Text>
                <View style={styles.dataContainer}>
                  <Text style={[styles.dataValue, { color: colors.text }]}>
                    {item.hz?.toFixed(2) || '0.00'}
                  </Text>
                  <Text style={[styles.dataUnit, { color: colors.text }]}>Hz</Text>
                </View>
                {item.sethz !== undefined && (
                  <Text style={[styles.frequencySetpoint, { color: colors.text }]}>
                    设定值: {item.sethz?.toFixed(2) || '0.00'} Hz
                  </Text>
                )}
                <CommandStatusDisplay deviceId={item.name} />
              </TouchableOpacity>
            ))}
          </View>
        </View>
      )}

      {devices.length > 0 && (
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>设备控制</Text>
          <View style={styles.cardGrid}>
            {devices.map((device) => (
              <View
                key={device.name}
                style={[styles.card, { backgroundColor: colors.card }, device.fault === 1 && styles.alarmCard]}
              >
                <Text style={[styles.cardTitle, { color: colors.text }]}>{device.name}</Text>
                <View style={styles.deviceControlContainer}>
                  <View style={styles.statusContainer}>
                    <Text style={[styles.deviceStatus, { color: device.run ? '#4CAF50' : '#FF5252' }]}>
                      {device.run ? '运行中' : '已停止'}
                    </Text>
                    {device.fault === 1 && (
                      <Text style={styles.alarmStatus}>报警</Text>
                    )}
                  </View>
                  <View style={styles.controlButtonContainer}>
                    <TouchableOpacity
                      onPress={() => handleDeviceControl(device.name, device.run ? 'stop' : 'start')}
                      disabled={pendingCommands[device.name]?.status === 'pending'}
                    >
                      <Text
                        style={[
                          styles.controlButton, 
                          { backgroundColor: device.run ? '#FF5252' : '#4CAF50' },
                          pendingCommands[device.name]?.status === 'pending' && { opacity: 0.6 }
                        ]}
                      >
                        {pendingCommands[device.name]?.status === 'pending' 
                          ? '处理中...' 
                          : device.run ? '停止' : '启动'}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
                <CommandStatusDisplay deviceId={device.name} />
              </View>
            ))}
          </View>
        </View>
      )}
      {isValve.length > 0 && (
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>阀门控制</Text>
          <View style={styles.cardGrid}>
            {isValve.map((valve) => (
              <View
                key={valve.name}
                style={[styles.card, { backgroundColor: colors.card }, valve.fault === 1 && styles.alarmCard]}
              >
                <Text style={[styles.cardTitle, { color: colors.text }]}>{valve.name}</Text>
                <View style={styles.deviceControlContainer}>
                  <View style={styles.statusContainer}>
                    <Text style={[styles.deviceStatus, { color: valve.open ? '#4CAF50' : valve.close ? '#FF5252' : '#FFA000' }]}>
                      {valve.open ? '开到位' : valve.close ? '关到位' : '状态未知'}
                    </Text>
                    {valve.fault === 1 && (
                      <Text style={styles.alarmStatus}>故障</Text>
                    )}
                  </View>
                  <View style={styles.controlButtonContainer}>
                    <TouchableOpacity
                      onPress={() => handleValveControl(
                        valve.name,
                        valve.open ? 'close' : 'open',
                        valve.openKey,
                        valve.closeKey
                      )}
                      disabled={valve.fault === 1 || pendingCommands[valve.name]?.status === 'pending'}
                    >
                      <Text
                        style={[
                          styles.controlButton,
                          { backgroundColor: valve.open ? '#FF5252' : '#4CAF50' },
                          (valve.fault === 1 || pendingCommands[valve.name]?.status === 'pending') && { opacity: 0.5 }
                        ]}
                      >
                        {pendingCommands[valve.name]?.status === 'pending' 
                          ? '处理中...' 
                          : valve.open ? '关闭' : '开启'}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
                <CommandStatusDisplay deviceId={valve.name} />
              </View>
            ))}
          </View>
        </View>
      )}
      </ScrollView>
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: colors.card }]}>
            <Text style={[styles.modalTitle, { color: colors.text }]}>
              {selectedDevice?.name} - 频率设定
            </Text>
            <TextInput
              style={[styles.frequencyInput, { 
                borderColor: colors.border,
                backgroundColor: colors.background,
                color: colors.text
              }]}
              placeholder="请输入频率值"
              placeholderTextColor={colors.text}
              keyboardType="numeric"
              value={newFrequency}
              onChangeText={setNewFrequency}
            />
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.modalButtonText}>取消</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={() => {
                  if (selectedDevice && newFrequency) {
                    handleSetFrequency(selectedDevice.name, newFrequency);
                    setModalVisible(false);
                  }
                }}
                disabled={pendingCommands[selectedDevice?.name]?.status === 'pending'}
              >
                <Text style={styles.modalButtonText}>
                  {pendingCommands[selectedDevice?.name]?.status === 'pending' ? '处理中...' : '确认'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 15,
  },
  connectionStatusContainer: {
    marginBottom: 15,
    backgroundColor: '#FFFFFF',
    padding: 10,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  connectionRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  connectionStatus: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 8,
  },
  connectionText: {
    fontSize: 14,
    fontWeight: '500',
    marginRight: 'auto',
  },
  lastUpdateText: {
    fontSize: 12,
    color: '#666666',
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 12,
    letterSpacing: 0.5,
    opacity: 0.9,
  },
  cardGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  card: {
    width: '48%',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.05)',
    backgroundColor: '#FFFFFF',
  },
  cardTitle: {
    fontSize: 13,
    fontWeight: '600',
    marginBottom: 6,
    letterSpacing: 0.2,
    opacity: 0.9,
  },
  dataContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
  },
  dataValue: {
    fontSize: 20,
    fontWeight: 'bold',
    marginRight: 3,
    letterSpacing: 0.3,
  },
  dataUnit: {
    fontSize: 11,
    opacity: 0.8,
  },
  deviceControlContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  deviceStatus: {
    fontSize: 13,
    fontWeight: '600',
    marginRight: 6,
    letterSpacing: 0.2,
  },
  alarmStatus: {
    color: '#FF5252',
    fontSize: 11,
    fontWeight: '600',
    backgroundColor: 'rgba(255, 82, 82, 0.15)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  controlButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
    color: '#FFFFFF',
    fontSize: 13,
    fontWeight: '600',
    overflow: 'hidden',
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 1,
  },
  frequencySetpoint: {
    fontSize: 11,
    marginTop: 4,
    opacity: 0.8,
    letterSpacing: 0.1,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    borderRadius: 10,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },
  frequencyInput: {
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    marginBottom: 15,
    fontSize: 16,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalButton: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 5,
    marginHorizontal: 5,
  },
  cancelButton: {
    backgroundColor: '#FF5252',
  },
  confirmButton: {
    backgroundColor: '#4CAF50',
  },
  modalButtonText: {
    color: '#FFFFFF',
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '500',
  },
  // 新增样式
  wsStatusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500'
  },
  statusBadge: {
    marginTop: 8,
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 4,
    borderWidth: 1,
    alignSelf: 'flex-start',
    backgroundColor: 'rgba(255, 255, 255, 0.8)'
  }
});

export default SiteDetailScreen;